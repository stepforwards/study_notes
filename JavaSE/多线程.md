---
title: 多线程
tags: 多线程,Thread,Java
grammar_cjkRuby: true
---


# 线程概念

**进程**：进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。

**线程**：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个进程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。

**简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程**

# 单线程
> 单线程程序：若有多个任务只能依次执行。当上一个任务执行结束后，下一个任务开始执行。

# 多线程

> 多线程程序：多个任务可以同时执行。

# 线程调度

> 线程调度是指按照特定机制为多个线程分配CPU的使用权，有两种调度模型：分时调度模型和抢占式调度模型。
> **分时调度**： 所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间
> **抢占式调度**： 优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，jvm采用抢占式调度模型
> 实际上，CPU使用抢占式调度在多个线程之间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而CPU在多个线程之间切换的速度相对于我们的感觉要快的多，看上去就是在同一时刻运行。多线程程序并不能提高程序的运行速度，但是能够提高CPU的使用率
 
 # 程序的主线程
 
 > jvm启动后，必然有一个执行路径(线程)从main方法开始的，一致执行main方法结束，这个线程在java中称之为主线程。主线程如果存在了耗时操作，例如循环等，那么在耗时操作完成之前，后续的代码是无法执行的，如果想要我们的主线程，不受循环的影响正常运行，就需要创建一个分线程，将这个耗时操作放入分线程中进行执行。

# Thread类

> 在java中开辟线程需要使用Thread这个类

# 构造方法

|   构造方法  |   描述  |
| :--- | :---: |
|   Thread()  |  分配一个新的Thread对象   |
| Thread(Runnable target)    |    分配一个新的Thread对象    |
| Thread(Runnable target,String name)    |   分配一个新的Thread对象     |
|   Thread(String name)  |    分配一个新的Thread对象    |

> 注意 name表示可以给线程起个名字

# 常用方法

|  返回值   |   方法名  |  描述   |
| :---: | :---: | :---: |
|  void   | start()    |  表示线程开始执行，java虚拟机调用线程的run方法   |
|void     | run()    |  如果这个线程使用单独的Runnable运行对象构造，则调用Runnable对象的run方法，否则不执行任何方法也不返回   |
| static void    |  sleep(long millis)   | 当前线程在指定毫秒值后暂停     |
|  String   | getName()    |   返回线程的名字  |
| static Thread     | currentThread()    | 返回当前正在执行对象的引用    |


**sleep(long millis)**  是静态方法，当使用Thread调用此方法的时候，这行代码写在那个线程中，就会让这个线程进行休眠

**currentThread()** 是静态方法，当时用Thread调用此方法的时候，这行代码写在那个线程中，获取的就是当前这个线程的对象

**run()** 方法的特点是返回值为void，并且不抛异常

# 创建线程的方式

## 方式一(继承Thread)

- 定义一个类继承Thread
- 重写run方法，将耗时操作写入run方法
- 创建子类对象，就是创建线程对象
- 调用start方法，开启线程让线程执行，同时还会告诉jvm去调用run方法
- 注意start()方法不能反复调用

``` java
public class MyThread extends Thread{ 

	@Override
	public void run() {
		for(int i = 0; i <= 100; i++) {
			System.out.println(i);
		}
	}
}

public class TestThread {

	public static void main(String[] args) {
		MyThread mth = new MyThread();
		mth.start();
	}
}
```


## 方式二(实现Runnable接口)

- 定义类实现Runnable接口
- 覆盖接口中的run方法
- 创建Thread类的对象
- 将Runnable接口的子类对象作为参数传递给Thread类的构造函数
- 调用Thread类的start开启线程

``` java
public class MyThread implements Runnable{
	@Override
	public void run() {
		for(int i = 0; i < 100; i++) {
			System.out.println(i);
		}
	} 
}

public class TestThread {

	public static void main(String[] args) {
		Thread thread1 = new Thread(new MyThread());
		// 给线程起名字
		Thread thread2 = new Thread(new MyThread(),"线程一");
		thread1.start();
		thread2.start();
	}
}

```


## 两种方式的比较

> 第二种方式实现Runnable接口避免了单继承的局限性，所以较为常用。实现Runnable接口的方式，更加的符合面向对象，线程分为两部分，一部分是线程对象，一部分线程任务。继承Thread类，线程对象和线程任务耦合在一起。一旦创建Thread类的子对象，即是线程对象，又有线程任务。实现Runnable接口，将线程任务单独分离出来封装成对象，类型就是Runnable接口类型。Runnable接口对线程和线程任务进行解耦。

## 线程运行的内部原理

- 多线程执行是，在栈内存中，其实没执行一个线程都有一遍自己所属的栈内存空间。进行方法的压栈和弹栈
- 当线程的任务结束了，线程自动在栈内存中释放，但是当所有的执行线程结束了，那么进程就结束了。
- 栈内存都是线程私有的

## 线程的匿名内部类调用

- 方式一：创建线程对象是，直接重写Thread类中的run方法

``` java
new Thread(){
	public void run() {
		for(int i = 0; i < 100; i++) {
			System.out.println(Thread.currentThread().getName() + i);
		}
	};
}.start();
```

- 方式二：使用匿名内部类的方式实现Runnable接口，重写Runnable接口中的run方法

``` java
new Thread(new Runnable() {
	@Override
	public void run() {
		for(int i = 0; i < 100; i++){
			System.out.println(Thread.currentThread().getName() + i);
		}
	}
}).start();
```





