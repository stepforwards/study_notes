---
title: 反射课件
tags: 反射,动态加载,Java
grammar_cjkRuby: true
---
[TOC]
## 什么是反射
> JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。

## 动态和静态的区别
静态：编译时加载信息
动态：运行时加载信息

举例说明（office例子）

## 反射--java的终极手段，是规则的破坏者

### new创建对象

创建对象的三个步骤：
在Stack创建局部变量，在heap中创建对象，然后将对象的地址给局部变量

![new 关键字创建对象示意图][1]

``` stylus
// 创建对象
	@Test
	public void newObject() {
		Person p = new Person();
		p.setAge(12);
		p.setName("张三");
		p.sayHello();
	}
```

### 反射创建对象
反射创建对象的步骤
1. 获取类的描述符
2. 得到类的构造方法
3. 通过类的构造方法获取实例对象

class ：定义类关键字
Class ： Class类，是类的描述符
Class的对象如何表述



在java的世界里面 ，万物皆对象

java的世界里面有两个不是面向对象的：
- 静态的成员
- 普通数据类型，但是它有包装类

``` stylus
	@Test
	public void newObjectInReflect() throws Exception {
		Class clazz = Person.class;
		// getName()是类的名称(完整类名)
		String name = clazz.getName();
		// getSimpleName()是类的名称(Person)
		String simpleName = clazz.getSimpleName();
		System.out.println("simpleName : " + simpleName);
		System.out.println(name);
		// 通过反射创建对象
		Object object = clazz.newInstance();
		System.out.println(object);
	}
```


### Constructor
> 构造函数的描述符。`Class clazz = Person.class`

``` stylus
	/**
	 * 无参构造函数
	 */
	@Test
	public void testConstructor() throws Exception {
		Class clazz = Person.class;
		// 得到类的构造函数
		Constructor ctor = clazz.getDeclaredConstructor();
		// 设置可访问性
		ctor.setAccessible(true);
		Object o = ctor.newInstance();
		System.out.println(o);
	}

	/**
	 * 有参构造函数
	 */
	@Test
	public void testConstructor2() throws Exception {
		Class clazz = Person.class;
		// 得到类的构造函数
		Constructor ctor = clazz.getDeclaredConstructor(String.class);
		Object o = ctor.newInstance("Allen");
		System.out.println(o);
	}

	/**
	 * 包装类构造函数
	 */
	@Test
	public void testConstructor3() throws Exception {
		Class clazz = Person.class;
		// 自动装箱
		Constructor ctor = clazz.getDeclaredConstructor(String.class, Integer.class);
		Object o = ctor.newInstance("Allen", 13);
		System.out.println(o);
	}

	/**
	 * 基本数据类型构造函数
	 */
	@Test
	public void testConstructor4() throws Exception {
		Class clazz = Person.class;
		// 自动拆箱
		Constructor ctor = clazz.getDeclaredConstructor(String.class, int.class);
		Object o = ctor.newInstance("Allen", 13);
		System.out.println(o);
	}
```


### Method ：方法描述符 
 
> 反射从类出发，从描述符，方法。出发

``` stylus
Constructor ctor = clazz.getConstuctor(...);
ctor.setAccessible(true);	// 设置可访问性
ctor.newInstance(....);
// 静态方法也可以通过反射访问
 m.invoke(null);
```

### Field
字段（成员变量）描述符。

``` stylus
	/**
	 * 字段描述符
	 * @throws Exception 
	 * @throws NoSuchFieldException 
	 */
	@Test
	public void testField() throws Exception {
		Class<Person> clazz = Person.class;
		Object obj = clazz.newInstance();
		// 获得字段描述符
		Field f = clazz.getDeclaredField("name");
		// 设置可访问性
		f.setAccessible(true);
		// 设置字段值===》p.name = "tom";
		f.set(obj, "tom");
		
		// 取出字段
		Object name = f.get(obj);
		System.out.println(name);
	}
```

### Modifier
	修饰符，判断是否有含有指定的修饰符的。
	
``` stylus
@Test
	public void testModifer() throws Exception {
		Class<Person> clazz = Person.class;
		Method m = clazz.getDeclaredMethod("setName",String.class);
		// 得到方法的修饰符总和,通过与运算求得所有修饰符的总和
		int modifier = m.getModifiers();
		// 
		System.out.println(modifier);
		
		System.out.println(Modifier.isPublic(modifier));
		System.out.println(Modifier.isPrivate(modifier));
	}
```
> 通过**或运算**获得所有修饰符的总和，查看Modifer的源码可以看到`public static final int PUBLIC           = 0x00000001;这些修饰符都是以二进制的形式显示的，并且没一个修饰符占一位二进制，所以判断是什么修饰符修饰的，只需要将这些修饰符按位进行取余即可。这种做法非常巧妙，进行与或运算速度很快，并且方法调用的频率比较多因此，大大的提高了性能。


## 练习
1. 获取一个类的声明方法和公有方法

``` stylus
	/**
	 * 获取类中声明的方法
	 * @throws Exception
	 */
	@Test
	public void testGetDeclaredMethod() throws Exception{
		Class<Person> clazz = Person.class;
		Method []ms = clazz.getDeclaredMethods();
		for(Method m : ms){
			System.out.println(m);
		}
	}+

	/**
	 * 获取类的公有方法
	 * @throws Exception
	 */
	@Test
	public void testGetMethod() throws Exception{
		Class<Person> clazz = Person.class;
		Method []ms = clazz.getMethods();
		for(Method m : ms){
			System.out.println(m);
		}
	}
```


2. 得到指定包下的所有的类

``` stylus
	/**
	 * 得到指定包下的所有类
	 * @throws Exception 
	 */
	@Test
	public void getClasses() throws Exception{
		Class clazz = Cat.class;
		// 类加载器的作用是将字节码文件(.class)加载到java虚拟机中
		ClassLoader loader = clazz.getClassLoader();
		
		// URL 统一资源定位符
		URL url = loader.getResource("top/xiesen/reflect/pojo");
		String dir = url.getPath();
		
		File file = new File(url.toURI());
		File[] Files = file.listFiles();
		
		for (File f : Files) {
			String fname = f.getName();
			if(!fname.endsWith(".class")){
				continue;
			}
			
			String className = fname.substring(0, fname.lastIndexOf("."));
			className = "top.xiesen.reflect.pojo." + className;
			clazz = Class.forName(className);
			System.out.println(clazz);
		}
	}
```


  [1]: https://www.github.com/xiesen310/notes_Images/raw/master/images/1502008146528.jpg